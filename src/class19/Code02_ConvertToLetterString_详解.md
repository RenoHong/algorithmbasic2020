# Code02_ConvertToLetterString 算法详解

## 问题描述

给定一个只包含数字字符0~9的字符串，将其转化为字母字符串。转化规则如下：
- 1 → A
- 2 → B
- ...
- 26 → Z

求有多少种不同的转化方案。

## 核心思想

每个数字可以：
1. **单独转化**：如 "1" → "A"
2. **与下一个数字组合转化**：如 "12" → "L" (前提是组合结果 ≤ 26)

特殊情况：遇到 '0' 时，必须与前一个数字组合（10 或 20），否则无效。

---

## 示例演示

### 示例 1: "111"

```
            "111"
           /     \
          /       \
       "1" + "11"   "11" + "1"
        |     /\       /\     |
        A   "1"+"1"  "1"+"1"  A
        |    |   |    |   |   |
        |    A   A    A   A   |
        |                     |
      "A A A"              "K A"
                            
      "A K"
```

转化方案：
1. "1" + "1" + "1" → A + A + A = "AAA"
2. "1" + "11" → A + K = "AK"  
3. "11" + "1" → K + A = "KA"

**答案：3种方案**

---

### 示例 2: "1201"

```
"1201"
  |
  └─ "1" + "201"
       |     |
       A   "20" + "1"  (不能选"2"+"01"，因为01无效)
             |     |
             T     A
             
结果: "ATA" (1种方案)
```

**答案：1种方案**

---

### 示例 3: "1001" (无效)

```
"1001"
  |
  └─ "10" + "01"
       |      ✗
       J    无效！（0不能开头）
       
结果: 无有效方案
```

**答案：0种方案**

---

## 三种解法对比

### 方法1: 递归 (number + process)

```
递归树示例 - "12":

              process(0)
             /          \
            /            \
      单转 "1"          组合 "12"
      process(1)        process(2)
       /      \              |
   单转"2"  组合"2?"      返回1
   process(2) (越界)
      |
    返回1

总方案数 = 1 + 1 = 2
```

**特点**：
- 自顶向下递归
- 从左向右处理字符串
- 每次决策：单转 或 双转

---

### 方法2: 从右往左的动态规划 (dp1)

```
示例: "111"

索引:  0   1   2   3
字符: [1] [1] [1]
dp:   [3] [2] [1] [1]
       ↑   ↑   ↑   ↑
       |   |   |   |
       |   |   |   基础case
       |   |   |
       |   |   单转:dp[3]=1
       |   |   双转:dp[4]=1(越界视为1)
       |   |   dp[2] = 1+1 = 2
       |   |
       |   单转:dp[2]=2
       |   双转:dp[3]=1
       |   dp[1] = 2+1 = 3
       |
       dp[0] = 3 (最终答案)

计算方向: ← ← ← ←
```

**DP数组含义**：`dp[i]` 表示从位置 i 到字符串末尾有多少种转化方式

**状态转移方程**：
```
dp[i] = dp[i+1]                                    // 单转
      + dp[i+2] (if 组合值 < 27)                  // 双转
```

---

### 方法3: 从左往右的动态规划 (dp2)

```
示例: "111"

索引:  0   1   2
字符: [1] [1] [1]
dp:   [1] [2] [3]
       ↑   ↑   ↑
       |   |   |
    基础  |   |
    dp[0]=1  |
       |   |
       |   考虑位置1的字符'1':
       |   - 单独: dp[0]=1
       |   - 与前面'1'组合成'11': +1
       |   dp[1] = 1 + 1 = 2
       |
       考虑位置2的字符'1':
       - 单独: dp[1]=2
       - 与前面'1'组合成'11': dp[0]=1
       dp[2] = 2 + 1 = 3

计算方向: → → →
```

**DP数组含义**：`dp[i]` 表示从字符串开头到位置 i 有多少种转化方式

**状态转移方程**：
```
if str[i] == '0':
    // 必须与前一个字符组合
    dp[i] = dp[i-2]  (需要检查合法性)
else:
    dp[i] = dp[i-1]                           // 单转
          + dp[i-2] (if 组合值 <= 26)        // 双转
```

---

## 关键边界条件

### 1. 字符 '0' 的处理

```
遇到 '0' 的情况分析：

合法：
  "10" → J (10)
  "20" → T (20)
  "110" → "1" + "10" = AJ 或 "11" + "0" (无效)

非法：
  "01" → ✗ (0不能单独)
  "30" → ✗ (30 > 26)
  "00" → ✗ (00无效)
```

### 2. 组合条件

```
可以组合的条件：
  str[i] 和 str[i+1] 组合值 < 27

示例：
  "26" → Z ✓
  "27" → 不能组合成一个字母 ✗
  "19" → S ✓
```

### 3. 空字符串和null

```
输入           返回值
null      →      0
""        →      0
"0"       →      0
"1"       →      1
```

---

## 复杂度分析

| 方法 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 递归 (number) | O(2^n) | O(n) | 指数级，最坏情况每个位置都有2种选择 |
| DP从右往左 (dp1) | O(n) | O(n) | 线性时间，需要dp数组 |
| DP从左往右 (dp2) | O(n) | O(n) | 线性时间，需要dp数组 |

**空间优化可能**：dp1和dp2都可以优化到O(1)空间，因为只需要维护最近的2-3个状态。

---

## 状态机图示

```
状态转换图：

     单个数字 '1'-'9'
    ┌─────────────────┐
    │                 │
    ▼                 │
  [Start] ──'1'-'9'──> [Valid State]
    │                      │  ▲
    │                      │  │
    │ '0'                  │  │ 组合成10-26
    ▼                      │  │
  [Invalid]                └──┘
                           
关键规则：
1. 遇到'0'必须回溯与前一个字符组合
2. 组合结果必须≤26
3. '0'不能单独存在
```

---

## 递归树完整示例："123"

```
                    process("123", 0)
                   /                  \
                  /                    \
            单转 '1'                  双转 '12'
           process(1)                process(2)
           /         \                    |
          /           \                   |
     单转 '2'      双转 '23'          单转 '3'
    process(2)     process(3)        process(3)
       /    \          |                  |
      /      \         |                  |
  单转'3'  双转'3?'   返回1             返回1
process(3) (越界)
    |
  返回1

方案统计：
1. "1" + "2" + "3" → ABC
2. "1" + "23" → AW
3. "12" + "3" → LC

答案：3种
```

---

## DP数组填充过程详解

### dp1 (从右往左) - "123"

```
初始状态：
index: 0   1   2   3
char: [1] [2] [3]
dp:   [?] [?] [?] [1]  ← 基础case

步骤1：i=2, char='3'
  单转: dp[3]=1
  双转: 无(越界)
  dp[2] = 1

index: 0   1   2   3
dp:   [?] [?] [1] [1]

步骤2：i=1, char='2'
  单转: dp[2]=1
  双转: '23'=23<27, dp[3]=1
  dp[1] = 1 + 1 = 2

index: 0   1   2   3
dp:   [?] [2] [1] [1]

步骤3：i=0, char='1'
  单转: dp[1]=2
  双转: '12'=12<27, dp[2]=1
  dp[0] = 2 + 1 = 3

index: 0   1   2   3
dp:   [3] [2] [1] [1]
       ↑
    最终答案
```

### dp2 (从左往右) - "123"

```
初始状态：
index: 0   1   2
char: [1] [2] [3]
dp:   [1] [?] [?]  ← 基础case: dp[0]=1

步骤1：i=1, char='2'
  str[1]≠'0'
  单转: dp[0]=1
  双转: '12'=12≤26, 加上dp[-1]=1(越界视为1)
  dp[1] = 1 + 1 = 2

index: 0   1   2
dp:   [1] [2] [?]

步骤2：i=2, char='3'
  str[2]≠'0'
  单转: dp[1]=2
  双转: '23'=23≤26, 加上dp[0]=1
  dp[2] = 2 + 1 = 3

index: 0   1   2
dp:   [1] [2] [3]
                ↑
             最终答案
```

---

## 特殊案例分析

### 案例1: "10"
```
递归：
  process(0): '1'+'0'组合
  → process(2): 返回1
  结果: 1种 (J)

dp1: [1, 1, 1]
dp2: [1, 1]
```

### 案例2: "06"
```
递归：
  process(0): str[0]='0'
  → 返回0 (0不能开头)
  结果: 0种

dp1: 立即返回0
dp2: str[0]='0' → 返回0
```

### 案例3: "27"
```
递归：
  process(0): 
    - 单转'2': process(1) → 单转'7': 1种
    - 双转'27': 27≥27，不能双转
  结果: 1种 (BG)

dp1: [1, 1, 1]
dp2: [1, 1]
```

### 案例4: "226"
```
方案：
1. "2" + "2" + "6" → BBF
2. "2" + "26" → BZ
3. "22" + "6" → VF

答案: 3种
```

---

## 算法选择建议

| 场景 | 推荐方法 | 理由 |
|------|---------|------|
| 理解算法原理 | 递归 (number) | 思路清晰，容易理解 |
| 生产环境 | DP (dp1或dp2) | 时间复杂度低，性能好 |
| 需要路径回溯 | 递归+记忆化 | 可以记录具体方案 |
| 超长字符串 | DP+空间优化 | 节省内存 |

---

## 总结

### 核心要点
1. **递归思路**：每个位置考虑单转或双转两种可能
2. **DP优化**：避免重复计算，时间从O(2^n)降到O(n)
3. **边界处理**：'0'字符的特殊处理是关键
4. **两个DP方向**：从右往左或从左往右都可以，思路略有不同

### 代码对应关系
- `number()` + `process()`: 暴力递归
- `dp1()`: 递归改DP，从右往左
- `dp2()`: 正向DP，从左往右

三种方法结果完全一致，测试用例验证了这一点。


# KM 问题：找出数组中出现K次的数

## 问题描述

给定一个整数数组，其中：
- **有且仅有一个数出现了 K 次**
- **其他所有数都出现了 M 次**
- **要求找出这个出现 K 次的数**

**约束条件**：
- K < M
- 要求时间复杂度 O(n)，空间复杂度 O(1)

## 算法思路

### 核心思想：位统计

KM问题是**异或找奇数次问题**的升级版。不能直接用异或（因为M可能是偶数或奇数），但可以利用**位运算统计每一位上1的出现次数**。

### 关键观察

1. **整数的二进制表示**：任何整数都可以表示为32位二进制
2. **位的独立性**：每一位（bit）的统计是独立的
3. **倍数关系**：
   - 如果某一位上所有数的1的个数能被M整除，说明出现K次的数在该位上是0
   - 如果某一位上所有数的1的个数 % M = K，说明出现K次的数在该位上是1
   - 如果某一位上所有数的1的个数 % M ≠ 0 且 ≠ K，说明不满足题目条件，返回-1

### 倍数关系详解（重要！）

#### 具体例子说明

假设数组：`[5, 5, 5, 7, 7, 7, 7, 7]`
- **K = 3**（数字5出现3次）
- **M = 5**（数字7出现5次）

**二进制表示**：
```
5 = 0b 101
7 = 0b 111
```

#### 逐位分析（从右到左：第0位、第1位、第2位）

**第0位（最右边）分析**：
```
5 = 0b 101  → 第0位是 1（有3个5）→ 贡献 3个1
7 = 0b 111  → 第0位是 1（有5个7）→ 贡献 5个1
总计：3 + 5 = 8个1

判断：8 % 5 = 3 = K ✓
结论：出现K次的数（5）在第0位是 1
```

**为什么？**
- 7出现了M=5次，在第0位贡献了5个1（5 % 5 = 0，被整除，可以"抵消"）
- 剩余的 8 - 5 = 3 个1，正好是5贡献的（5出现K=3次）
- 所以5在第0位必定是1

---

**第1位（中间）分析**：
```
5 = 0b 101  → 第1位是 0（有3个5）→ 贡献 0个1
7 = 0b 111  → 第1位是 1（有5个7）→ 贡献 5个1
总计：0 + 5 = 5个1

判断：5 % 5 = 0 ✓
结论：出现K次的数（5）在第1位是 0
```

**为什么？**
- 7出现了M=5次，在第1位贡献了5个1（正好被M整除）
- 5在第1位是0，贡献了0个1
- 总数5能被M=5整除，说明只有"出现M次的数"在这一位有贡献
- 所以5在第1位必定是0

---

**第2位（最左边）分析**：
```
5 = 0b 101  → 第2位是 1（有3个5）→ 贡献 3个1
7 = 0b 111  → 第2位是 1（有5个7）→ 贡献 5个1
总计：3 + 5 = 8个1

判断：8 % 5 = 3 = K ✓
结论：出现K次的数（5）在第2位是 1
```

---

**还原答案**：
```
第0位：1
第1位：0
第2位：1

答案 = 0b 101 = 5 ✓
```

#### 三种情况的数学原理

设：
- **A** = 出现K次的数在某一位上的值（0或1）
- **B** = 所有出现M次的数在该位上1的总个数

**该位上1的总数** = `A × K + B`

由于其他数都出现M次，B必然是M的倍数（可能是0, M, 2M, 3M...）

##### 情况1：总数 % M = 0
```
A × K + B ≡ 0 (mod M)
```
因为 B ≡ 0 (mod M)，所以：
```
A × K ≡ 0 (mod M)
```
因为 K < M 且 K ≠ 0，所以 **A 必定是 0**

**结论：出现K次的数在该位上是0**

---

##### 情况2：总数 % M = K
```
A × K + B ≡ K (mod M)
```
因为 B ≡ 0 (mod M)，所以：
```
A × K ≡ K (mod M)
```
所以 **A 必定是 1**

**结论：出现K次的数在该位上是1**

---

##### 情况3：总数 % M ≠ 0 且 ≠ K
```
A × K + B ≡ R (mod M)，其中 R ≠ 0 且 R ≠ K
```

这种情况说明：
- 如果 A = 0，则 `B ≡ R (mod M)`，但B应该是M的倍数，矛盾！
- 如果 A = 1，则 `K + B ≡ R (mod M)`，因为B是M的倍数，应该余K，矛盾！

**结论：不满足题目条件（不是恰好一个数出现K次，其他都出现M次）**

#### 反例演示（情况3）

假设数组：`[5, 5, 7, 7, 7, 7, 7]`（5只出现2次，不是K=3次）
- K = 3, M = 5

**第0位统计**：
```
5 = 0b 101  → 第0位是 1（有2个5）→ 贡献 2个1
7 = 0b 111  → 第0位是 1（有5个7）→ 贡献 5个1
总计：2 + 5 = 7个1

判断：7 % 5 = 2
2 ≠ 0 且 2 ≠ K(3) ✗

返回 -1：不满足条件！
```

#### 倍数关系总结表

| 情况 | 公式 | 含义 | 操作 |
|------|------|------|------|
| `t[i] % M = 0` | 总数能被M整除 | K次的数在第i位是**0** | ans保持0 |
| `t[i] % M = K` | 总数模M余K | K次的数在第i位是**1** | `ans \|= (1 << i)` |
| `t[i] % M = R`<br>(R≠0且R≠K) | 总数模M余其他值 | 不满足题目条件 | 返回-1 |

**核心理解**：所有出现M次的数在某一位的贡献必定是M的倍数，剩余的部分只能是0或K，据此判断出现K次的数在该位是0还是1。

---

## 算法步骤详解

### 第一步：创建位索引映射（优化）

```java
public static void mapCreater(HashMap<Integer, Integer> map) {
    int value = 1;
    for (int i = 0; i < 32; i++) {
        map.put(value, i);
        value <<= 1;
    }
}
```

**作用**：创建从"单一位值"到"位索引"的映射
- `1 (0b00001)` → 索引 0
- `2 (0b00010)` → 索引 1
- `4 (0b00100)` → 索引 2
- `8 (0b01000)` → 索引 3
- ...
- `2^31` → 索引 31

**用途**：快速定位某个位是第几位，避免每次都要计算

### 第二步：统计每一位上1的出现次数

```java
int[] t = new int[32];  // t[i]表示第i位上1出现的次数
for (int num : arr) {
    while (num != 0) {
        int rightOne = num & (-num);  // 提取最右边的1
        t[map.get(rightOne)]++;       // 该位的计数+1
        num ^= rightOne;              // 删除这个1，继续处理，异或运算的结果相同为0，不同为1
    }
}
```

**详细解析**：

#### 2.1 提取最右边的1
```java
int rightOne = num & (-num);
```
- **原理**：`-num` 是 `num` 的补码（取反加1）
- **效果**：只保留最右边的1，其他位都变成0

**示例**：
```
num        = 0b 0010 1100  (44)
-num       = 0b 1101 0100  (补码)
num & -num = 0b 0000 0100  (4，即第2位)
```

#### 2.2 统计该位
```java
t[map.get(rightOne)]++;
```
- 通过映射表找到这是第几位
- 该位的计数器加1

#### 2.3 删除这个1
```java
num ^= rightOne;
```
- 用异或删除已处理的最右边的1
- 继续处理下一个1

**示例完整过程**：
```
原数字 num = 44 = 0b 0010 1100

第1次循环：
  rightOne = 0b 0000 0100 (第2位)
  t[2]++
  num = 0b 0010 1100 ^ 0b 0000 0100 = 0b 0010 1000

第2次循环：
  rightOne = 0b 0000 1000 (第3位)
  t[3]++
  num = 0b 0010 1000 ^ 0b 0000 1000 = 0b 0010 0000

第3次循环：
  rightOne = 0b 0010 0000 (第5位)
  t[5]++
  num = 0b 0010 0000 ^ 0b 0010 0000 = 0b 0000 0000

循环结束，统计完成
```

### 第三步：根据统计结果还原答案

```java
int ans = 0;
for (int i = 0; i < 32; i++) {
    if (t[i] % m != 0) {              // 该位上的1的总数不能被M整除
        if (t[i] % m == k) {          // 余数必须等于K
            ans |= (1 << i);          // 将第i位设为1。将1 移动i位在或，或运算的结果有1就是1.
        } else {
            return -1;                // 不满足条件，返回-1
        }
    }
}
```

**逻辑分析**：

对于第 i 位：
- **情况1**：`t[i] % m == 0`
  - 说明出现M次的那些数在第i位上1的总数是M的倍数
  - 出现K次的数在第i位上是0
  - 不需要操作，ans的第i位保持为0

- **情况2**：`t[i] % m == k`
  - 说明出现K次的数在第i位上是1（贡献了K个1）
  - 其他数贡献的1正好被M整除抵消
  - 将ans的第i位设为1：`ans |= (1 << i)`

- **情况3**：`t[i] % m != 0` 且 `t[i] % m != k`
  - 不满足题目条件（说明不是恰好一个数出现K次，其他出现M次）
  - 返回-1

### 第四步：处理特殊情况（ans == 0）

```java
if (ans == 0) {
    int count = 0;
    for (int num : arr) {
        if (num == 0) {
            count++;
        }
    }
    if (count != k) {
        return -1;
    }
}
```

**为什么需要这个特判？**

- 如果答案本身就是0，ans会等于0
- 但ans初始化也是0，无法区分"答案是0"还是"没找到答案"
- 所以需要验证：如果ans=0，检查数组中0的个数是否等于K
- 如果不等于K，说明实际上没有任何数出现K次，返回-1

## 算法复杂度分析

### 时间复杂度：O(n)
- 遍历数组一次：O(n)
- 每个数字处理其二进制位：每个数字最多32位，O(32) = O(1)
- 还原答案：遍历32位，O(32) = O(1)
- **总体**：O(n × 1 + 1) = O(n)

### 空间复杂度：O(1)
- t数组：固定32个元素，O(32) = O(1)
- map映射：固定32个键值对，O(32) = O(1)
- 其他变量：O(1)
- **总体**：O(1)

## 完整示例

假设数组：`arr = [2, 2, 3, 3, 3, 4, 4]`，K=1，M=2
- 数字2出现2次（M次）
- 数字3出现3次（需要特殊处理，这里假设符合条件）
- 数字4出现2次（M次）

**二进制表示**：
```
2 = 0b 010
3 = 0b 011
4 = 0b 100
```

**位统计**：
```
第0位（2^0）：3出现3次 → 贡献3个1
          2出现0次 → 贡献0个1
          4出现0次 → 贡献0个1
          总计：3个1，3 % 2 = 1 = K ✓

第1位（2^1）：3出现3次 → 贡献3个1
          2出现2次 → 贡献2个1
          4出现0次 → 贡献0个1
          总计：5个1，5 % 2 = 1 = K ✓

第2位（2^2）：3出现0次 → 贡献0个1
          2出现0次 → 贡献0个1
          4出现2次 → 贡献2个1
          总计：2个1，2 % 2 = 0 ✓
```

**还原答案**：
- 第0位：余数=1=K，设为1
- 第1位：余数=1=K，设为1
- 第2位：余数=0，保持0
- **答案**：`0b 011 = 3`

## 算法优势

1. **空间效率高**：只用O(1)的额外空间
2. **不依赖哈希表**：纯位运算，性能稳定
3. **通用性强**：适用于任意K < M的情况
4. **可扩展**：可以轻松修改支持64位整数

## 与异或问题的对比

| 特性 | 异或问题（偶数次/奇数次） | KM问题 |
|------|------------------------|--------|
| **原理** | 利用 a ^ a = 0 | 利用位统计和模运算 |
| **限制** | 必须是偶数次 vs 奇数次 | K < M，任意K和M |
| **复杂度** | O(n) 时间，O(1) 空间 | O(n) 时间，O(1) 空间 |
| **实现难度** | 简单 | 中等 |
| **应用场景** | 特定情况（M=2） | 通用情况 |

## 关键技巧总结

1. **提取最右边的1**：`rightOne = num & (-num)`
2. **删除最右边的1**：`num ^= rightOne` 或 `num &= (num - 1)`
3. **位索引映射**：预处理加速位运算
4. **模运算判断**：通过 `t[i] % m` 判断该位的值
5. **特殊值处理**：单独处理0作为答案的情况

## 代码优化建议

### 优化1：不使用映射表（直接计算位索引）
```java
while (num != 0) {
    int rightOne = num & (-num);
    // 直接计算位索引，不用映射表
    int bitIndex = Integer.numberOfTrailingZeros(num);
    t[bitIndex]++;
    num ^= rightOne;
}
```

### 优化2：Brian Kernighan算法（更快地遍历所有1）
```java
while (num != 0) {
    num &= (num - 1);  // 直接删除最右边的1
    // 但这样需要记录删除的是哪一位，所以原算法更清晰
}
```

## 应用场景

1. **数据流处理**：海量数据中找特殊元素
2. **内存受限环境**：嵌入式系统、物联网设备
3. **面试题**：考察位运算和数学思维
4. **网络通信**：错误检测和纠正
5. **硬件设计**：数字电路中的状态检测

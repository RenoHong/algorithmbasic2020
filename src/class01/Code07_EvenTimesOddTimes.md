# 异或运算找出现奇数次的数

## 算法核心：异或运算的特征和定律

### 1. **交换律和结合律**
```
a ^ b = b ^ a  （交换律）
(a ^ b) ^ c = a ^ (b ^ c)  （结合律）
```
- **作用**：数组中元素的异或顺序不影响最终结果
- **应用**：可以任意调整异或的顺序，相同的数会自动配对消除

### 2. **自反性（消除律）**
```
a ^ a = 0
```
- **作用**：任何数与自己异或结果为0
- **核心原理**：出现偶数次的数会两两配对异或，最终全部消除为0
- **应用场景**：这是算法能够找出奇数次数字的根本原因

### 3. **恒等律**
```
a ^ 0 = a
```
- **作用**：任何数与0异或还是本身
- **应用**：当所有偶数次的数消除为0后，剩下的就是出现奇数次的数

### 4. **位的差异性**
```
a ^ b 的结果中，为1的位表示a和b在该位上不同
```
- **作用**：通过异或结果判断两个数在哪些位上有差异
- **应用**：在找两个奇数次数字时，通过 `eor & (~eor + 1)` 提取最右边的1
- **原理**：这个位置上两个数必然不同（一个为0，一个为1），可以据此分组

### 5. **可逆性**
```
a ^ b ^ b = a
(a ^ b) ^ a = b
```
- **作用**：异或运算可以"撤销"
- **应用1**：无临时变量交换两数
  ```java
  a = a ^ b;  // a变成了a^b
  b = a ^ b;  // b = (a^b) ^ b = a
  a = a ^ b;  // a = (a^b) ^ a = b
  ```
- **应用2**：找第二个奇数次的数：`eor ^ onlyOne`

## 算法实现原理

### 问题1：找一个出现奇数次的数
**思路**：将所有数异或
```java
int eor = 0;
for (int i = 0; i < arr.length; i++) {
    eor ^= arr[i];
}
```
**原理**：
- 出现偶数次的数：`a ^ a ^ a ^ a = 0`（两两消除）
- 出现奇数次的数：`b ^ b ^ b = b`（剩下一个）
- 最终结果：`0 ^ b = b`

### 问题2：找两个出现奇数次的数
**思路**：分而治之
```java
// 第一步：得到两个数的异或结果
int eor = 0;  // eor = a ^ b
for (int i = 0; i < arr.length; i++) {
    eor ^= arr[i];
}

// 第二步：提取eor中最右边的1（a和b的不同位）
int rightOne = eor & (~eor + 1);

// 第三步：根据这一位将数组分成两组，分别异或
int onlyOne = 0;
for (int i = 0; i < arr.length; i++) {
    if ((arr[i] & rightOne) != 0) {
        onlyOne ^= arr[i];  // 得到第一个数
    }
}

// 第四步：利用可逆性得到第二个数
int anotherOne = eor ^ onlyOne;
```

**原理**：
1. **eor = a ^ b**：所有偶数次的数消除，剩下两个奇数次数的异或
2. **rightOne**：提取a和b不同的某一位（最右边的1）
3. **分组**：根据这一位是0还是1，将数组分成两组
   - a和b必然在不同组
   - 相同的数必然在同一组（会被消除）
4. **分别求解**：每组内只有一个奇数次的数

## 关键技巧

### 提取最右边的1
```java
int rightOne = eor & (~eor + 1);
```
**原理**（取反加一法）：
- `~eor`：按位取反
- `~eor + 1`：补码（二进制中会在最右边的1处进位）
- `eor & (~eor + 1)`：只保留最右边的1，其他位都为0

**示例**：
```
eor      = 0110 1100
~eor     = 1001 0011
~eor + 1 = 1001 0100
相与结果  = 0000 0100  （只保留了最右边的1）
```

## 算法精髓

通过异或的**自反性**让偶数次出现的数自动归零，利用**位差异性**将两个奇数次的数分到不同组别再分别求解。整个过程：
- **时间复杂度**：O(n)
- **空间复杂度**：O(1)
- **优雅之处**：不需要额外的数据结构，仅用位运算即可解决

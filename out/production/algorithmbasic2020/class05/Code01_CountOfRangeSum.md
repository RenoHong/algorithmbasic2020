### 归并排序

设前缀和数组为 preSum，则问题等价于求所有的下标对(i,j)，满足

> preSum[j] − preSum[i] ∈ [lower,upper]

我们先考虑如下的问题：给定两个升序排列的数组 `n1`,`n2`，试找出所有的下标对 `(i,j)`，满足

> n2[j] − n1[i] ∈ [lower,upper]

在已知两个数组均为升序的情况下，这一问题是相对简单的：
我们在 `n2`中维护两个指针 `l`,`r`。起初，它们都指向 `n2` 的起始位置。随后，我们考察
`n1` 的第一个元素。首先，不断地将指针 `l` 向右移动，直到
> n2[l] ≥ n1[0]+lower

为止，此时， `ll` 及其右边的元素均大于或等于 `n1[0] + lower `；
随后，再不断地将指针`r` 向右移动，直到 `n2[r] >n1 [0] + upper`为止，则`r`左边的元素均小于或等于`n1[0] + upper`, 故区间
`[l,r)`中的所有下标`j`，都满足

> n2[j] − n1[0] ∈ [lower,upper]

接下来，我们考察`n1`的第二个元素。由于`n1` 是递增的，不难发现 `l`,`r` 只可能向右移动。因此，我们不断地进行上述过程，并对于`n1`
中的每一个下标，都记录相应的区间 [l,r) 的大小。最终，我们就统计得到了满足条件的下标对 (i,j) 的数量。

在解决这一问题后，原问题就迎刃而解了：我们采用归并排序的方式，能够得到左右两个数组排序后的形式，以及对应的下标对数量。对于原数组而言，若要找出全部的下标对数量，只需要再额外找出左端点在左侧数组，同时右端点在右侧数组的下标对数量，而这正是我们此前讨论的问题。

### 解法一说明：为什么可以归并

看完后我明白如果数组是有序的，那么可以容易的求出区间数量，那么为什么对数组排序前后所求的区间数量不会改变呢，下面我来说明一下（官方并没有实际说明这一点）

初始归并：
此时只会有0或1个元素，不涉及左右两段的情况，是可以的

合并归并：此时是有左右两段的，左右两段是分别有序的，对前缀和数组排序并不会修改数组中元素的值，只是改变了元素是位置，如对left ~
`right=3~5`位置的前缀和排序，排序后前缀和`3 ~ 5`位置的数还是原来`3 ~ 5`位置的数，只是排列变化了

设想一个一般的情况，现在是某一层的递归，左，右两段区间`left ~ mid, mid+1 ~
right`的符合要求的区间数量已经通过`countRangeSumRecursive`计算了出来，整个`left ~
right`区间中可能的符合要求的区间情况是两端点在`left ~ mid`中；两端点在`mid+1 ~ right；一个端点在left~ mid中，一个端点在mid+1~
right`中，所以现在只要求出第三种情况的区间数量就可以了
通过上面的说明，`left ~ mid`,`mid+1~ right`区间中的数还是原来区间中的数，只是顺序变成了有序，而有序是容易计算符合要求的区间数量的，一个图说明为什么第三种情况排序前后符合数量的区间数量是不变的

### 指路：如何学习本题的算法和数据结构

忽略官方题解中的方法一，剩余的四种方法分别使用了线段树、树状数组和平衡树。这些方法都不是面试的考点，甚至在笔试中也很少出现，所以大部分读者应该是完全不知道这些都是啥神奇的数据结构的。所以我觉得这里有必要补充以下两点：

这道题需要哪些接口。
上面的这些神奇的数据结构可以提供哪些接口。
题目描述

给定数组 A，它的长度为 n，对应的元素以及下标为`A[0],A[1],⋯,A[n−1]`。

令 `S(i,j)` 为`A[i]` 到 `A[j]` 的和，即

> S(i,j)=∑jk=iA[k]

题目需要求出满足lower≤S(i,j)≤upper 的二元组 (i, j)(i,j) 的个数。

换成人话就是，问数组 A 有多少个连续的子数组，其元素只和在 [lower,upper] 的范围内。

题目分析

暴力的做法是使用前缀和。令 P 为 A 的前缀和数组，那么

S(i, j) = P[j] - P[i-1]

可以在O(1) 的时间求出。这里我们规定边界 P[-1] = 0。

这样一来，我们枚举所有的二元组 (i, j)，算出S(i,j) 并判断其是否在范围内即可。时间复杂度为O(n2)。

那么怎么进行优化呢？我们考虑从小到大枚举 j，由于

lower≤P[j]−P[i−1]≤upper

我们可以得到 P[i-1] 应该满足的不等式

P[j]−upper≤P[i−1]≤P[j]−lower

因此本质上，我们需要一个数据结构支持下面的两个操作：

操作 1「查询」：给定一个范围 [left,right]，查询数据结构中在该范围内的元素个数。对应到本题中，我们给定的范围就是[P[j]
−upper,P[j]−lower]；

操作 2「更新」：给定一个元素 xx，我们需要把它添加到数据结构中。对应到本题中，我们给定的元素就是 P[j]。

如果有了这样一个数据结构，我们就可以很方便地做出本题：

我们首先将 00 放入数据结构中，随后我们从小到大枚举 j，查询 [P[j]−upper,P[j]−lower]
范围内的元素个数并计入答案。在查询完成之后，我们将P[j] 添加进数据结构，就可以进行下一次枚举。

[Details](https://liudufu.github.io/The_number_of_interval_sums/)
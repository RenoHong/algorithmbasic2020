# Class 01 - 排序基础与二分查找详解

## 📚 课程概览

本课程涵盖了算法学习的基础内容：
- **三大基础排序**：选择排序、冒泡排序、插入排序
- **二分查找**：标准二分及其变种
- **位运算应用**：使用异或解决问题

---

## 1️⃣ 选择排序 (Selection Sort)

### 算法思想

选择排序的核心思想：**每次从未排序部分选出最小元素，放到已排序部分的末尾**。

### 算法步骤

```
初始数组：[64, 25, 12, 22, 11]

第1轮：在 [64, 25, 12, 22, 11] 中找最小值 11，与位置0交换
结果：  [11] | 25, 12, 22, 64

第2轮：在 [25, 12, 22, 64] 中找最小值 12，与位置1交换
结果：  [11, 12] | 25, 22, 64

第3轮：在 [25, 22, 64] 中找最小值 22，与位置2交换
结果：  [11, 12, 22] | 25, 64

第4轮：在 [25, 64] 中找最小值 25，已在正确位置
结果：  [11, 12, 22, 25] | 64

完成：  [11, 12, 22, 25, 64]
```

### 可视化过程

```
轮次    未排序区域          最小值  已排序区域
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
初始    [64, 25, 12, 22, 11]  -     []

轮1     [64, 25, 12, 22, 11]  11    []
         ↓找最小值11，与位置0交换↓
        [11] 25  12  22  64    -     [11]

轮2      25  12  22  64        12    [11]
         ↓找最小值12，与位置1交换↓
         25 [12] 22  64         -     [11, 12]

轮3      25  22  64            22    [11, 12]
         ↓找最小值22，与位置2交换↓
         25 [22] 64             -     [11, 12, 22]

轮4      25  64                25    [11, 12, 22]
         ↓找最小值25，已在正确位置↓
        [25] 64                 -     [11, 12, 22, 25]

完成     64                    -     [11, 12, 22, 25, 64]
```

### 核心代码

```java
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    
    // 外层循环：已排序边界从0扩展到n-1
    for (int i = 0; i < arr.length - 1; i++) {
        // 假设当前位置是最小值
        int minIndex = i;
        
        // 内层循环：在未排序部分找最小值
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;  // 更新最小值索引
            }
        }
        
        // 将最小值交换到已排序部分末尾
        swap(arr, i, minIndex);
    }
}

public static void swap(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
```

### 详细示例

**示例1：正序数组**
```
输入：[1, 2, 3, 4, 5]
第1轮：最小值1在位置0，不交换 → [1, 2, 3, 4, 5]
第2轮：最小值2在位置1，不交换 → [1, 2, 3, 4, 5]
第3轮：最小值3在位置2，不交换 → [1, 2, 3, 4, 5]
第4轮：最小值4在位置3，不交换 → [1, 2, 3, 4, 5]
输出：[1, 2, 3, 4, 5]
比较次数：10次（4+3+2+1）
交换次数：0次
```

**示例2：逆序数组**
```
输入：[5, 4, 3, 2, 1]
第1轮：最小值1在位置4，交换 → [1, 4, 3, 2, 5]
第2轮：最小值2在位置3，交换 → [1, 2, 3, 4, 5]
第3轮：最小值3在位置2，不交换 → [1, 2, 3, 4, 5]
第4轮：最小值4在位置3，不交换 → [1, 2, 3, 4, 5]
输出：[1, 2, 3, 4, 5]
比较次数：10次
交换次数：2次
```

### 性能分析

| 指标 | 值 | 说明 |
|------|-----|------|
| **时间复杂度（最好）** | O(n²) | 已排序数组仍需全部比较 |
| **时间复杂度（平均）** | O(n²) | 总是需要 n(n-1)/2 次比较 |
| **时间复杂度（最坏）** | O(n²) | 逆序数组 |
| **空间复杂度** | O(1) | 原地排序 |
| **稳定性** | ❌ 不稳定 | 相同元素相对位置会改变 |
| **比较次数** | n(n-1)/2 | 固定 |
| **交换次数** | 0 ~ n-1 | 最多n-1次交换 |

**不稳定性示例：**
```
输入：[5a, 8, 5b, 2]（a、b标记相同值的不同元素）
第1轮：最小值2，交换5a和2 → [2, 8, 5b, 5a]
     ⚠️ 注意：5a和5b的相对顺序改变了！
第2轮：最小值5b → [2, 5b, 8, 5a]
第3轮：最小值5a → [2, 5b, 5a, 8]
输出：[2, 5b, 5a, 8]
```

### 优缺点

**✅ 优点：**
- 实现简单，代码量少
- 交换次数少（最多n-1次）
- 原地排序，不需要额外空间

**❌ 缺点：**
- 时间复杂度高（O(n²)）
- 不稳定排序
- 无法利用数组已有的有序性

---

## 2️⃣ 冒泡排序 (Bubble Sort)

### 算法思想

冒泡排序的核心思想：**相邻元素两两比较，较大的"冒泡"到右侧**。

### 算法步骤

```
初始数组：[64, 34, 25, 12, 22]

第1轮（范围0-4）：
  64 vs 34：交换 → [34, 64, 25, 12, 22]
  64 vs 25：交换 → [34, 25, 64, 12, 22]
  64 vs 12：交换 → [34, 25, 12, 64, 22]
  64 vs 22：交换 → [34, 25, 12, 22, 64] ✓ 64到达末尾

第2轮（范围0-3）：
  34 vs 25：交换 → [25, 34, 12, 22 | 64]
  34 vs 12：交换 → [25, 12, 34, 22 | 64]
  34 vs 22：交换 → [25, 12, 22, 34 | 64] ✓ 34到达正确位置

第3轮（范围0-2）：
  25 vs 12：交换 → [12, 25, 22 | 34, 64]
  25 vs 22：交换 → [12, 22, 25 | 34, 64] ✓ 25到达正确位置

第4轮（范围0-1）：
  12 vs 22：不交换 → [12, 22 | 25, 34, 64] ✓

完成：[12, 22, 25, 34, 64]
```

### 可视化过程

```
第1轮：每次比较相邻元素，大的向右移动

初始：64  34  25  12  22
      ↓↓
比较：34  64  25  12  22  (64 > 34，交换)
          ↓↓
比较：34  25  64  12  22  (64 > 25，交换)
              ↓↓
比较：34  25  12  64  22  (64 > 12，交换)
                  ↓↓
比较：34  25  12  22 [64] (64 > 22，交换，64到达末尾)

第2轮：对前4个元素重复上述过程

开始：34  25  12  22 | 64
      ↓↓
比较：25  34  12  22 | 64
          ↓↓
比较：25  12  34  22 | 64
              ↓↓
比较：25  12  22 [34]| 64  (34到达正确位置)

第3轮：

开始：25  12  22 | 34  64
      ↓↓
比较：12  25  22 | 34  64
          ↓↓
比较：12  22 [25]| 34  64  (25到达正确位置)

第4轮：

开始：12  22 | 25  34  64
      ↓↓
比较：12  22 | 25  34  64  (不交换，已有序)

完成：[12, 22, 25, 34, 64]
```

### 核心代码

```java
public static void bubbleSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    
    // 外层循环：未排序边界从右向左缩小
    for (int e = arr.length - 1; e > 0; e--) {
        // 内层循环：将最大值"冒泡"到右侧
        for (int i = 0; i < e; i++) {
            if (arr[i] > arr[i + 1]) {
                swap(arr, i, i + 1);
            }
        }
    }
}

// 使用异或交换（注意：i和j不能相同）
public static void swap(int[] arr, int i, int j) {
    arr[i] = arr[i] ^ arr[j];  // arr[i] = a ^ b
    arr[j] = arr[i] ^ arr[j];  // arr[j] = (a^b) ^ b = a
    arr[i] = arr[i] ^ arr[j];  // arr[i] = (a^b) ^ a = b
}
```

### 异或交换详解

**原理：**
- `a ^ a = 0`（任何数与自己异或等于0）
- `a ^ 0 = a`（任何数与0异或等于自己）
- `a ^ b ^ b = a`（异或满足结合律和交换律）

**步骤演示：**
```
假设 arr[i] = 5 (101), arr[j] = 3 (011)

第1步：arr[i] = arr[i] ^ arr[j]
      arr[i] = 5 ^ 3 = 101 ^ 011 = 110 = 6
      状态：arr[i]=6, arr[j]=3

第2步：arr[j] = arr[i] ^ arr[j]
      arr[j] = 6 ^ 3 = 110 ^ 011 = 101 = 5
      状态：arr[i]=6, arr[j]=5

第3步：arr[i] = arr[i] ^ arr[j]
      arr[i] = 6 ^ 5 = 110 ^ 101 = 011 = 3
      状态：arr[i]=3, arr[j]=5

完成交换！
```

**⚠️ 注意：** 当 i == j 时，异或交换会出错（结果为0）！
```
例如：arr[i] = 5, i = j
第1步：arr[i] = 5 ^ 5 = 0
第2步：arr[i] = 0 ^ 0 = 0
第3步：arr[i] = 0 ^ 0 = 0
结果：arr[i] = 0（错误！）
```

### 详细示例

**示例1：包含重复元素**
```
输入：[3, 3, 1, 2]

第1轮：
  3 vs 3：不交换 → [3, 3, 1, 2]
  3 vs 1：交换   → [3, 1, 3, 2]
  3 vs 2：交换   → [3, 1, 2, 3]

第2轮：
  3 vs 1：交换   → [1, 3, 2 | 3]
  3 vs 2：交换   → [1, 2, 3 | 3]

第3轮：
  1 vs 2：不交换 → [1, 2 | 3, 3]

输出：[1, 2, 3, 3]
```

**示例2：近似有序数组**
```
输入：[1, 2, 4, 3, 5]

第1轮：
  1 vs 2：不交换
  2 vs 4：不交换
  4 vs 3：交换 → [1, 2, 3, 4, 5]
  4 vs 5：不交换

第2轮：
  1 vs 2：不交换
  2 vs 3：不交换
  3 vs 4：不交换
  ✓ 已完全有序（可优化提前退出）

输出：[1, 2, 3, 4, 5]
```

### 性能分析

| 指标 | 值 | 说明 |
|------|-----|------|
| **时间复杂度（最好）** | O(n) | 已排序，可优化 |
| **时间复杂度（平均）** | O(n²) | 随机数组 |
| **时间复杂度（最坏）** | O(n²) | 逆序数组 |
| **空间复杂度** | O(1) | 原地排序 |
| **稳定性** | ✅ 稳定 | 相同元素不交换 |
| **比较次数** | n(n-1)/2 | 最坏情况 |
| **交换次数** | 0 ~ n(n-1)/2 | 视数组有序程度 |

### 优化版本

```java
public static void bubbleSortOptimized(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    
    for (int e = arr.length - 1; e > 0; e--) {
        boolean swapped = false;  // 标记是否发生交换
        
        for (int i = 0; i < e; i++) {
            if (arr[i] > arr[i + 1]) {
                swap(arr, i, i + 1);
                swapped = true;
            }
        }
        
        // 如果本轮没有交换，说明已排序，提前退出
        if (!swapped) {
            break;
        }
    }
}
```

**优化效果：**
```
输入：[1, 2, 3, 4, 5]（已排序）
第1轮：无交换，swapped=false → 提前退出
时间复杂度：O(n)
```

### 优缺点

**✅ 优点：**
- 稳定排序，适合需要保持相对顺序的场景
- 实现简单
- 可优化（提前检测已排序）
- 对近似有序的数组效率较高

**❌ 缺点：**
- 时间复杂度高（O(n²)）
- 交换次数多
- 大规模数据效率低

---

## 3️⃣ 插入排序 (Insertion Sort)

### 算法思想

插入排序的核心思想：**维护一个已排序部分，每次从未排序部分取一个元素，插入到已排序部分的正确位置**。

### 算法步骤

```
初始数组：[12, 11, 13, 5, 6]

初始：[12] | 11, 13, 5, 6
      已排序 | 未排序

轮1：取11，插入到已排序部分
  11 vs 12：11 < 12，向左移动
  [11, 12] | 13, 5, 6

轮2：取13，插入到已排序部分
  13 vs 12：13 > 12，位置正确
  [11, 12, 13] | 5, 6

轮3：取5，插入到已排序部分
  5 vs 13：5 < 13，向左移动
  5 vs 12：5 < 12，向左移动
  5 vs 11：5 < 11，向左移动
  [5, 11, 12, 13] | 6

轮4：取6，插入到已排序部分
  6 vs 13：6 < 13，向左移动
  6 vs 12：6 < 12，向左移动
  6 vs 11：6 < 11，向左移动
  6 vs 5：6 > 5，停止
  [5, 6, 11, 12, 13] |

完成：[5, 6, 11, 12, 13]
```

### 可视化过程

```
像整理扑克牌一样，逐张插入到正确位置

初始状态：
  手中（已排序）：[12]
  桌上（未排序）：11, 13, 5, 6

第1步：取11
  比较：11 vs 12
  ←← 11小，向左插
  手中：[11, 12]
  桌上：13, 5, 6

第2步：取13
  比较：13 vs 12
  → 13大，插在后面
  手中：[11, 12, 13]
  桌上：5, 6

第3步：取5
  比较：5 vs 13 → ←←
        5 vs 12 → ←←
        5 vs 11 → ←←
  插到最前面
  手中：[5, 11, 12, 13]
  桌上：6

第4步：取6
  比较：6 vs 13 → ←←
        6 vs 12 → ←←
        6 vs 11 → ←←
        6 vs 5  → 停止
  插到5后面
  手中：[5, 6, 11, 12, 13]
  桌上：（空）

完成！
```

### 核心代码

```java
public static void insertionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    
    // 外层循环：扩展已排序部分（从1到n-1）
    for (int i = 1; i < arr.length; i++) {
        // 内层循环：将arr[i]插入到正确位置
        // 从i-1向左比较，如果左边元素更大就交换
        for (int j = i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
            swap(arr, j, j + 1);
        }
    }
}

// 使用异或交换
public static void swap(int[] arr, int i, int j) {
    arr[i] = arr[i] ^ arr[j];
    arr[j] = arr[i] ^ arr[j];
    arr[i] = arr[i] ^ arr[j];
}
```

### 详细执行过程

**示例：[5, 2, 4, 6, 1, 3]**

```
i=1, 取2：
  j=0: 2 < 5，交换
  [2, 5, 4, 6, 1, 3]

i=2, 取4：
  j=1: 4 < 5，交换
  [2, 4, 5, 6, 1, 3]
  j=0: 4 > 2，停止

i=3, 取6：
  j=2: 6 > 5，停止
  [2, 4, 5, 6, 1, 3]

i=4, 取1：
  j=3: 1 < 6，交换
  [2, 4, 5, 1, 6, 3]
  j=2: 1 < 5，交换
  [2, 4, 1, 5, 6, 3]
  j=1: 1 < 4，交换
  [2, 1, 4, 5, 6, 3]
  j=0: 1 < 2，交换
  [1, 2, 4, 5, 6, 3]

i=5, 取3：
  j=4: 3 < 6，交换
  [1, 2, 4, 5, 3, 6]
  j=3: 3 < 5，交换
  [1, 2, 4, 3, 5, 6]
  j=2: 3 < 4，交换
  [1, 2, 3, 4, 5, 6]
  j=1: 3 > 2，停止

完成：[1, 2, 3, 4, 5, 6]
```

### 性能分析

| 指标 | 值 | 说明 |
|------|-----|------|
| **时间复杂度（最好）** | O(n) | 已排序数组 |
| **时间复杂度（平均）** | O(n²) | 随机数组 |
| **时间复杂度（最坏）** | O(n²) | 逆序数组 |
| **空间复杂度** | O(1) | 原地排序 |
| **稳定性** | ✅ 稳定 | 相同元素不交换 |
| **比较次数** | n(n-1)/4 | 平均情况 |
| **交换次数** | n(n-1)/4 | 平均情况 |

### 不同情况的性能

**1. 已排序数组**
```
输入：[1, 2, 3, 4, 5]
i=1: 2 vs 1 → 不交换
i=2: 3 vs 2 → 不交换
i=3: 4 vs 3 → 不交换
i=4: 5 vs 4 → 不交换
比较次数：4次
交换次数：0次
时间复杂度：O(n)
```

**2. 逆序数组**
```
输入：[5, 4, 3, 2, 1]
i=1: 4需移动1次
i=2: 3需移动2次
i=3: 2需移动3次
i=4: 1需移动4次
比较次数：10次（1+2+3+4）
交换次数：10次
时间复杂度：O(n²)
```

**3. 近似有序**
```
输入：[1, 3, 2, 4, 5]
i=1: 3 vs 1 → 不交换
i=2: 2 vs 3 → 交换1次
i=3: 4 vs 2 → 不交换
i=4: 5 vs 4 → 不交换
比较次数：5次
交换次数：1次
时间复杂度：接近O(n)
```

### 优缺点

**✅ 优点：**
- 稳定排序
- 对近似有序的数组非常高效
- 在线算法（可边输入边排序）
- 实现简单
- 小规模数据效率高

**❌ 缺点：**
- 大规模数据效率低（O(n²)）
- 逆序数组性能差

### 应用场景

1. **小规模数据排序**（n < 50）
2. **近似有序的数据**
3. **在线排序**（数据逐个到达）
4. **作为其他算法的子过程**（如快排的优化）

---

## 4️⃣ 二分查找 (Binary Search)

### 算法思想

二分查找的核心思想：**在有序数组中，每次将搜索范围缩小一半**。

**前提条件：** 数组必须是有序的！

### 基本二分查找

#### 算法步骤

```
在有序数组 [1, 3, 5, 7, 9, 11, 13, 15] 中查找 7

初始：L=0, R=7, 范围=[1...15]

第1次：mid = (0+7)/2 = 3
  arr[3] = 7 = 目标值
  找到！返回索引3

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

查找 10（不存在）：

第1次：L=0, R=7, mid=3
  arr[3] = 7 < 10
  目标在右半部分，L=4

第2次：L=4, R=7, mid=5
  arr[5] = 11 > 10
  目标在左半部分，R=4

第3次：L=4, R=4, mid=4
  arr[4] = 9 < 10
  目标在右半部分，L=5

第4次：L=5, R=4
  L > R，查找失败，返回-1
```

#### 可视化过程

```
数组：[1, 3, 5, 7, 9, 11, 13, 15]
索引： 0  1  2  3  4   5   6   7

查找目标：13

步骤1：
       L              M               R
       ↓              ↓               ↓
      [1, 3, 5, 7, 9, 11, 13, 15]
                      ↑
                  arr[3]=7 < 13
                  搜索右半部分

步骤2：
                      L   M       R
                      ↓   ↓       ↓
       1  3  5  7    [9, 11, 13, 15]
                         ↑
                     arr[5]=11 < 13
                     搜索右半部分

步骤3：
                          L   M   R
                          ↓   ↓   ↓
       1  3  5  7  9  11 [13, 15]
                          ↑
                      arr[6]=13 = 13
                      找到！返回6
```

#### 核心代码

```java
public static boolean exist(int[] sortedArr, int num) {
    if (sortedArr == null || sortedArr.length == 0) {
        return false;
    }
    
    int L = 0;
    int R = sortedArr.length - 1;
    
    while (L <= R) {  // 注意：L <= R
        // 计算中点（防止整数溢出）
        int mid = L + ((R - L) >> 1);  // 等价于 (L+R)/2
        
        if (sortedArr[mid] == num) {
            return true;  // 找到
        } else if (sortedArr[mid] > num) {
            R = mid - 1;  // 搜索左半部分
        } else {
            L = mid + 1;  // 搜索右半部分
        }
    }
    
    return false;  // 未找到
}
```

#### 关键点解析

**1. 为什么用 `L + ((R - L) >> 1)` 而不是 `(L + R) / 2`？**

```
原因：防止整数溢出

假设：L = 2000000000, R = 2000000000
错误：(L + R) / 2 = 4000000000 / 2
      ⚠️ 4000000000 超过int最大值（2147483647）！

正确：L + ((R - L) >> 1)
     = 2000000000 + (0 >> 1)
     = 2000000000  ✓

>> 1 表示右移1位，等价于除以2，但更快
```

**2. 循环条件为什么是 `L <= R`？**

```
如果用 L < R：
  当L=R时会提前退出，漏掉最后一个元素

正确做法：
  L <= R 确保检查所有元素
  退出时 L = R + 1
```

#### 详细示例

**示例1：目标在数组中**
```
数组：[2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
查找：23

第1次：L=0, R=9, mid=4
  arr[4]=16 < 23 → L=5

第2次：L=5, R=9, mid=7
  arr[7]=56 > 23 → R=6

第3次：L=5, R=6, mid=5
  arr[5]=23 = 23 → 找到！返回true

总比较次数：3次
```

**示例2：目标不在数组中**
```
数组：[2, 5, 8, 12, 16, 23, 38, 56, 72, 91]
查找：20

第1次：L=0, R=9, mid=4
  arr[4]=16 < 20 → L=5

第2次：L=5, R=9, mid=7
  arr[7]=56 > 20 → R=6

第3次：L=5, R=6, mid=5
  arr[5]=23 > 20 → R=4

第4次：L=5, R=4
  L > R → 未找到，返回false

总比较次数：3次
```

### 二分查找变种1：查找 >= value 的最左位置

#### 问题描述

在有序数组中，找到 **大于等于目标值** 的 **最左边** 的元素位置。

#### 算法思想

```
数组：[1, 2, 2, 2, 3, 4, 5]
查找：>= 2 的最左位置

答案：索引1（第一个2的位置）

核心思路：
1. 找到 >= value 的位置就记录
2. 继续向左搜索，看有没有更左的
3. 最终返回最左的位置
```

#### 可视化过程

```
数组：[1, 2, 2, 2, 3, 4, 5]
索引： 0  1  2  3  4  5  6
查找：>= 2 的最左位置

步骤1：
       L        M        R
       ↓        ↓        ↓
      [1, 2, 2, 2, 3, 4, 5]
               ↑
           arr[3]=2 >= 2
           记录index=3，继续向左搜索

步骤2：
       L    M   R
       ↓    ↓   ↓
      [1, 2, 2] 2  3  4  5
           ↑
       arr[1]=2 >= 2
       记录index=1，继续向左搜索

步骤3：
       L M  R
       ↓ ↓  ↓
      [1]2  2  2  3  4  5
       ↑
   arr[0]=1 < 2
   搜索右半部分

步骤4：
          LR
          ↓↓
       1 [2] 2  2  3  4  5
          ↑
      arr[1]=2 >= 2
      记录index=1，继续向左搜索

步骤5：L=2, R=0
      L > R，退出
      返回index=1
```

#### 核心代码

```java
public static int nearestIndex(int[] arr, int value) {
    int L = 0;
    int R = arr.length - 1;
    int index = -1;  // 记录最左的满足条件的位置
    
    while (L <= R) {
        int mid = L + ((R - L) >> 1);
        
        if (arr[mid] >= value) {
            index = mid;    // 记录当前位置
            R = mid - 1;    // 继续向左搜索
        } else {
            L = mid + 1;    // 搜索右半部分
        }
    }
    
    return index;
}
```

#### 详细示例

**示例1：有多个相同值**
```
数组：[1, 3, 3, 3, 3, 5, 7]
查找：>= 3

第1次：L=0, R=6, mid=3
  arr[3]=3 >= 3 → index=3, R=2

第2次：L=0, R=2, mid=1
  arr[1]=3 >= 3 → index=1, R=0

第3次：L=0, R=0, mid=0
  arr[0]=1 < 3 → L=1

第4次：L=1, R=0
  L > R → 返回index=1

结果：索引1（最左边的3）
```

**示例2：目标值不存在**
```
数组：[1, 3, 5, 7, 9]
查找：>= 4

第1次：L=0, R=4, mid=2
  arr[2]=5 >= 4 → index=2, R=1

第2次：L=0, R=1, mid=0
  arr[0]=1 < 4 → L=1

第3次：L=1, R=1, mid=1
  arr[1]=3 < 4 → L=2

第4次：L=2, R=1
  L > R → 返回index=2

结果：索引2（5是第一个>=4的数）
```

**示例3：所有元素都小于目标**
```
数组：[1, 2, 3, 4, 5]
查找：>= 10

第1次：L=0, R=4, mid=2
  arr[2]=3 < 10 → L=3

第2次：L=3, R=4, mid=3
  arr[3]=4 < 10 → L=4

第3次：L=4, R=4, mid=4
  arr[4]=5 < 10 → L=5

第4次：L=5, R=4
  L > R → 返回index=-1

结果：-1（不存在）
```

### 二分查找变种2：查找局部最小值

#### 问题描述

在一个**无序但相邻元素不相等**的数组中，找到任意一个局部最小值。

**局部最小的定义：**
- 如果是第一个元素：比第二个元素小
- 如果是最后一个元素：比倒数第二个元素小
- 如果是中间元素：比左右两个邻居都小

#### 算法思想

```
数组：[9, 5, 3, 8, 4, 7, 6]

可能的局部最小：
- 索引0（9）：不是，因为5 < 9
- 索引2（3）：是，因为3 < 5 且 3 < 8
- 索引4（4）：是，因为4 < 8 且 4 < 7

我们只需找到其中一个即可
```

#### 核心思想

```
关键洞察：
1. 如果arr[0] < arr[1]，那么arr[0]就是局部最小
2. 如果arr[n-1] < arr[n-2]，那么arr[n-1]就是局部最小
3. 否则，arr[0]...arr[n-1]形成一个"山谷"，必然存在局部最小

如何使用二分？
- 如果arr[mid] > arr[mid-1]，说明左侧有"下降趋势"，局部最小在左边
- 如果arr[mid] > arr[mid+1]，说明右侧有"下降趋势"，局部最小在右边
- 如果arr[mid] < arr[mid-1] 且 < arr[mid+1]，找到了！
```

#### 可视化过程

```
数组：[8, 6, 7, 5, 4, 6, 3]
画成折线图：

   8
     \
      6 - 7
          \
           5
            \
             4 - 6
                 \
                  3

步骤1：检查边界
  arr[0]=8 > arr[1]=6 → 不是
  arr[6]=3 < arr[5]=6 → 是！直接返回6

如果边界都不是：

数组：[6, 8, 7, 5, 4, 6, 9]
画成折线图：

      8
     / \
    6   7
         \
          5
           \
            4 - 6
                \
                 9

步骤1：边界不满足，进入二分

步骤2：L=1, R=5, mid=3
       arr[3]=5
       arr[2]=7 > arr[3] ✓
       arr[4]=4 < arr[3] ✗
       → 下降趋势在右侧，搜索右半部分

步骤3：L=4, R=5, mid=4
       arr[4]=4
       arr[3]=5 > arr[4] ✓
       arr[5]=6 > arr[4] ✓
       → 找到！返回4
```

#### 核心代码

```java
public static int getLessIndex(int[] arr) {
    if (arr == null || arr.length == 0) {
        return -1;
    }
    
    // 检查第一个元素
    if (arr.length == 1 || arr[0] < arr[1]) {
        return 0;
    }
    
    // 检查最后一个元素
    if (arr[arr.length - 1] < arr[arr.length - 2]) {
        return arr.length - 1;
    }
    
    // 二分查找
    int left = 1;
    int right = arr.length - 2;
    
    while (left < right) {
        int mid = left + ((right - left) >> 1);
        
        if (arr[mid] > arr[mid - 1]) {
            // 左侧有下降，搜索左边
            right = mid - 1;
        } else if (arr[mid] > arr[mid + 1]) {
            // 右侧有下降，搜索右边
            left = mid + 1;
        } else {
            // 找到局部最小
            return mid;
        }
    }
    
    return left;
}
```

#### 详细示例

**示例1：边界是局部最小**
```
数组：[1, 3, 2, 4, 5]

检查arr[0]=1：
  1 < 3 → arr[0]是局部最小
  返回0
```

**示例2：中间是局部最小**
```
数组：[5, 3, 4, 2, 6]

检查边界：都不是

二分查找：
  mid=2, arr[2]=4
  arr[1]=3 < arr[2] → 左侧有下降
  搜索左半部分

  mid=1, arr[1]=3
  arr[0]=5 > arr[1] ✓
  arr[2]=4 > arr[1] ✓
  找到！返回1
```

**示例3：多个局部最小**
```
数组：[9, 5, 7, 3, 8, 4, 6]
           ↑      ↑      
         局部最小1  局部最小2

二分可能找到任意一个：

第1次：mid=3, arr[3]=3
  arr[2]=7 > arr[3] ✓
  arr[4]=8 > arr[3] ✓
  找到！返回3
```

### 性能对比

| 算法 | 时间复杂度 | 空间复杂度 | 前提条件 |
|------|----------|----------|---------|
| 二分查找 | O(log n) | O(1) | 有序数组 |
| >= value 最左 | O(log n) | O(1) | 有序数组 |
| 局部最小 | O(log n) | O(1) | 相邻不等 |
| 线性查找 | O(n) | O(1) | 无要求 |

---

## 5️⃣ 异或运算的应用

### 异或基础知识

**异或（XOR）的性质：**
```
1. a ^ a = 0        （任何数异或自己等于0）
2. a ^ 0 = a        （任何数异或0等于自己）
3. 交换律：a ^ b = b ^ a
4. 结合律：(a ^ b) ^ c = a ^ (b ^ c)
```

**示例：**
```
5 ^ 5 = 0
  101
^ 101
-----
  000

5 ^ 0 = 5
  101
^ 000
-----
  101

5 ^ 3 = 6
  101
^ 011
-----
  110
```

### 问题1：找出现奇数次的数（其他数出现偶数次）

#### 问题描述

数组中只有一个数出现奇数次，其他数都出现偶数次，找出这个数。

#### 算法思想

```
利用性质：a ^ a = 0

例如：
[3, 3, 2, 3, 1, 1, 1, 3, 1, 1, 1]
3出现4次（偶数），2出现1次（奇数），1出现7次（奇数）

将所有数异或：
3^3^2^3^1^1^1^3^1^1^1
= (3^3^3^3) ^ (1^1^1^1^1^1) ^ 2  （重新排列）
= 0 ^ 1 ^ 2                       （偶数个相同的异或为0）
= 1 ^ 2                           （只剩下1和2）
```

等等，这个例子有问题！让我重新来：

```
正确例子：
[3, 3, 2, 3, 1, 1, 1, 3, 1, 1]
3出现4次（偶数），2出现1次（奇数），1出现5次（奇数）

但题目说"只有一个数出现奇数次"，所以应该是：
[3, 3, 3, 2, 2, 1]
只有3出现3次（奇数），2和1都出现2次（偶数）

异或过程：
3 ^ 3 ^ 3 ^ 2 ^ 2 ^ 1 ^ 1
= (3 ^ 3 ^ 3) ^ (2 ^ 2) ^ (1 ^ 1)
= 3 ^ 0 ^ 0
= 3
```

#### 核心代码

```java
public static void printOddTimesNum1(int[] arr) {
    int eor = 0;
    for (int i = 0; i < arr.length; i++) {
        eor ^= arr[i];
    }
    System.out.println(eor);  // 输出出现奇数次的数
}
```

#### 详细示例

```
输入：[3, 3, 2, 3, 1, 1, 1, 3, 1, 1, 1]

步骤演示：
eor = 0
eor ^= 3  → eor = 3
eor ^= 3  → eor = 0
eor ^= 2  → eor = 2
eor ^= 3  → eor = 1  (二进制：010 ^ 011 = 001)
eor ^= 1  → eor = 0
eor ^= 1  → eor = 1
eor ^= 1  → eor = 0
eor ^= 3  → eor = 3
eor ^= 1  → eor = 2
eor ^= 1  → eor = 3
eor ^= 1  → eor = 2

输出：2（出现1次，奇数）
```

### 问题2：找两个出现奇数次的数

#### 问题描述

数组中有两个数出现奇数次，其他数都出现偶数次，找出这两个数。

#### 算法思想

```
假设两个数是 a 和 b

步骤1：全体异或得到 eor = a ^ b

步骤2：提取 eor 最右边的1
  这一位在 a 和 b 中必然不同（一个是0，一个是1）
  
步骤3：根据这一位将数组分成两组
  - 这一位是1的一组
  - 这一位是0的一组
  a 和 b 必然分别在两组中
  
步骤4：对第一组异或，得到其中一个数
       用 eor 异或这个数，得到另一个数
```

#### 提取最右边的1

```
假设 eor = 6 = 110（二进制）

步骤：
1. ~eor = ...11111001（取反）
2. ~eor + 1 = ...11111010（加1，即-eor）
3. eor & (~eor + 1) = 110 & ...11111010 = 010 = 2

结果：提取出最右边的1（第2位）

原理：
  eor:     ...00000110
  ~eor:    ...11111001
  ~eor+1:  ...11111010
          ___________
  eor&:    ...00000010  （只保留最右边的1）
```

#### 核心代码

```java
public static void printOddTimesNum2(int[] arr) {
    int eor = 0;
    
    // 步骤1：全体异或
    for (int i = 0; i < arr.length; i++) {
        eor ^= arr[i];
    }
    // 现在 eor = a ^ b
    
    // 步骤2：提取最右边的1
    int rightOne = eor & (~eor + 1);  // 也可写成 eor & -eor
    
    // 步骤3：根据这一位分组并异或第一组
    int onlyOne = 0;
    for (int i = 0; i < arr.length; i++) {
        if ((arr[i] & rightOne) != 0) {  // 这一位是1
            onlyOne ^= arr[i];
        }
    }
    
    // onlyOne 是其中一个数，eor ^ onlyOne 是另一个
    System.out.println(onlyOne + " " + (eor ^ onlyOne));
}
```

#### 详细示例

```
输入：[4, 3, 4, 2, 2, 2, 4, 1, 1, 1, 3, 3, 1, 1, 1, 4, 2, 2]
其中 3 出现5次，1 出现7次（都是奇数）
其他数出现偶数次

步骤1：全体异或
eor = 3 ^ 1 = 011 ^ 001 = 010 = 2

步骤2：提取最右边的1
rightOne = 2 & -2 = 010 & 110 = 010
（最右边的1在第2位）

步骤3：分组
第2位=1的数：3(011), 2(010), 3(011), 2(010), 3(011), 2(010), 2(010)
第2位=0的数：4(100), 4(100), 4(100), 1(001), 1(001), 1(001), 4(100), 1(001), 1(001)

步骤4：对第2位=1的组异或
onlyOne = 3 ^ 2 ^ 3 ^ 2 ^ 3 ^ 2 ^ 2
        = 3 ^ 3 ^ 3 ^ 2 ^ 2 ^ 2 ^ 2
        = 3 ^ 0
        = 3

步骤5：计算另一个数
eor ^ onlyOne = 2 ^ 3 = 1

输出：3 和 1
```

#### 可视化分解

```
数组：[4, 3, 4, 2, 2, 2, 4, 1, 1, 1, 3, 3, 1, 1, 1, 4, 2, 2]

二进制表示：
4: 100
3: 011
2: 010
1: 001

全体异或：
100^011^100^010^010^010^100^001^001^001^011^011^001^001^001^100^010^010
= 010 (= 2，这是 3^1 的结果)

提取最右边的1：
010 & 110 = 010 (第2位)

按第2位分组：

第2位=1的组（包含3）：
  3(011), 2(010), 3(011), 2(010), 3(011), 2(010), 2(010)
  异或结果 = 3

第2位=0的组（包含1）：
  4(100), 4(100), 4(100), 1(001), 1(001), 1(001), 4(100), 1(001), 1(001)
  异或结果 = 1

答案：3 和 1
```

---

## 📊 三大排序性能对比

### 时间复杂度对比

| 排序算法 | 最好情况 | 平均情况 | 最坏情况 | 空间复杂度 | 稳定性 |
|---------|---------|---------|---------|-----------|--------|
| **选择排序** | O(n²) | O(n²) | O(n²) | O(1) | ❌ |
| **冒泡排序** | O(n) | O(n²) | O(n²) | O(1) | ✅ |
| **插入排序** | O(n) | O(n²) | O(n²) | O(1) | ✅ |

### 操作次数对比

**对于 n=5 的数组：**

| 算法 | 比较次数 | 交换次数（最坏） | 交换次数（最好） |
|------|---------|---------------|---------------|
| 选择排序 | 10 | 4 | 0 |
| 冒泡排序 | 10 | 10 | 0 |
| 插入排序 | 10 | 10 | 0 |

### 适用场景

| 排序算法 | 最佳使用场景 |
|---------|------------|
| **选择排序** | 交换成本高的场景（如大对象排序） |
| **冒泡排序** | 需要稳定性且数据近似有序 |
| **插入排序** | 小规模数据或近似有序数据 |

### 实际性能测试

```
测试数据：随机整数数组，n = 10000

选择排序：约 200ms
冒泡排序：约 300ms（无优化）
插入排序：约 150ms（数据随机）

测试数据：近似有序数组，n = 10000

选择排序：约 200ms（不受影响）
冒泡排序：约 50ms（优化版）
插入排序：约 20ms（最优）
```

---

## 🎯 关键要点总结

### 选择排序
- ✅ 交换次数最少
- ✅ 代码简单
- ❌ 不稳定
- ❌ 时间复杂度总是O(n²)

### 冒泡排序
- ✅ 稳定排序
- ✅ 可优化（检测已排序）
- ❌ 交换次数多
- ❌ 大规模数据慢

### 插入排序
- ✅ 稳定排序
- ✅ 对近似有序数据高效
- ✅ 在线算法
- ❌ 逆序数据性能差

### 二分查找
- ✅ 非常快速 O(log n)
- ⚠️ 必须是有序数组
- 💡 有多种变种解决不同问题

### 异或运算
- 💥 无需额外空间
- 💥 O(n) 时间复杂度
- 💡 适合查找特殊元素

---

## 🔧 练习建议

1. **手写实现**：不看代码，手写三种排序
2. **对比测试**：用相同数据测试三种排序的性能
3. **理解稳定性**：构造数据验证稳定性差异
4. **二分查找**：实现所有变种，理解边界条件
5. **异或应用**：尝试解决更多异或相关问题

---

## 📚 补充练习题

1. 实现逆序对计数（利用排序）
2. 寻找数组中的第k小元素（不完全排序）
3. 实现二分查找的递归版本
4. 找出数组中缺失的数字（异或）
5. 判断两个数组是否互为排列（异或）

